{"ast":null,"code":"//split text into sentences, using regex\n//@spencermountain MIT\n//(Rule-based sentence boundary segmentation) - chop given text into its proper sentences.\n// Ignore periods/questions/exclamations used in acronyms/abbreviations/numbers, etc.\n// @spencermountain 2015 MIT\nvar abbreviations = require('../_data/abbreviations');\n\nvar abbrev_reg = new RegExp('(^| |\\')(' + abbreviations.join('|') + \")[.!?] ?$\", 'i');\nvar acronym_reg = new RegExp('[ |.][A-Z].? +?$', 'i');\nvar elipses_reg = new RegExp('\\\\.\\\\.\\\\.* +?$');\nvar hasWord = new RegExp('[a-zа-яぁ-ゟ][a-zа-яぁ-ゟ゠-ヿ]', 'iu'); // 3040-309F : hiragana\n// 30A0-30FF : katakana\n//turn a nested array into one array\n\nvar flatten = function flatten(arr) {\n  var all = [];\n  arr.forEach(function (a) {\n    all = all.concat(a);\n  });\n  return all;\n};\n\nvar naiive_split = function naiive_split(text) {\n  //first, split by newline\n  var splits = text.split(/(\\n+)/);\n  splits = splits.filter(function (s) {\n    return s.match(/\\S/);\n  }); //split by period, question-mark, and exclamation-mark\n\n  splits = splits.map(function (str) {\n    return str.split(/(\\S.+?[.!?]\"?)(?=\\s+|$)/g); //\\u3002\n  });\n  return flatten(splits);\n}; // if this looks like a period within a wikipedia link, return false\n\n\nvar isBalanced = function isBalanced(str) {\n  str = str || '';\n  var open = str.split(/\\[\\[/) || [];\n  var closed = str.split(/\\]\\]/) || [];\n\n  if (open.length > closed.length) {\n    return false;\n  } //make sure quotes are closed too\n\n\n  var quotes = str.match(/\"/g);\n\n  if (quotes && quotes.length % 2 !== 0 && str.length < 900) {\n    return false;\n  }\n\n  return true;\n};\n\nvar sentence_parser = function sentence_parser(text) {\n  var sentences = []; //first do a greedy-split..\n\n  var chunks = []; //ensure it 'smells like' a sentence\n\n  if (!text || typeof text !== 'string' || text.trim().length === 0) {\n    return sentences;\n  } // This was the splitter regex updated to fix quoted punctuation marks.\n  // let splits = text.split(/(\\S.+?[.\\?!])(?=\\s+|$|\")/g);\n  // todo: look for side effects in this regex replacement:\n\n\n  var splits = naiive_split(text); //filter-out the grap ones\n\n  for (var i = 0; i < splits.length; i++) {\n    var s = splits[i];\n\n    if (!s || s === '') {\n      continue;\n    } //this is meaningful whitespace\n\n\n    if (!s.match(/\\S/)) {\n      //add it to the last one\n      if (chunks[chunks.length - 1]) {\n        chunks[chunks.length - 1] += s;\n        continue;\n      } else if (splits[i + 1]) {\n        //add it to the next one\n        splits[i + 1] = s + splits[i + 1];\n        continue;\n      }\n    }\n\n    chunks.push(s);\n  } //detection of non-sentence chunks\n\n\n  var isSentence = function isSentence(hmm) {\n    if (hmm.match(abbrev_reg) || hmm.match(acronym_reg) || hmm.match(elipses_reg)) {\n      return false;\n    } //too short? - no consecutive letters\n\n\n    if (hasWord.test(hmm) === false) {\n      return false;\n    }\n\n    if (!isBalanced(hmm)) {\n      return false;\n    }\n\n    return true;\n  }; //loop through these chunks, and join the non-sentence chunks back together..\n\n\n  for (var _i = 0; _i < chunks.length; _i++) {\n    //should this chunk be combined with the next one?\n    if (chunks[_i + 1] && !isSentence(chunks[_i])) {\n      chunks[_i + 1] = chunks[_i] + (chunks[_i + 1] || ''); //.replace(/ +/g, ' ');\n    } else if (chunks[_i] && chunks[_i].length > 0) {\n      //this chunk is a proper sentence..\n      sentences.push(chunks[_i]);\n      chunks[_i] = '';\n    }\n  } //if we never got a sentence, return the given text\n\n\n  if (sentences.length === 0) {\n    return [text];\n  }\n\n  return sentences;\n};\n\nmodule.exports = sentence_parser; // console.log(sentence_parser('Tony is nice. He lives in Japan.').length === 2);","map":null,"metadata":{},"sourceType":"script"}