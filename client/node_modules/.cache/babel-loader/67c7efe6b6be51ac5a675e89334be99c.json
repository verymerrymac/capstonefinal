{"ast":null,"code":"var parseSentence = require('../../../04-sentence/').oneSentence;\n\nvar findRows = require('./_findRows');\n\nvar handleSpans = require('./_spans'); //common ones\n\n\nvar headings = {\n  name: true,\n  age: true,\n  born: true,\n  date: true,\n  year: true,\n  city: true,\n  country: true,\n  population: true,\n  count: true,\n  number: true\n}; //additional table-cruft to remove before parseLine method\n\nvar cleanText = function cleanText(str) {\n  str = parseSentence(str).text(); //anything before a single-pipe is styling, so remove it\n\n  if (str.match(/\\|/)) {\n    str = str.replace(/.+\\| ?/, ''); //class=\"unsortable\"|title\n  }\n\n  str = str.replace(/style=['\"].*?[\"']/, ''); //'!' is used as a highlighed-column\n\n  str = str.replace(/^!/, '');\n  str = str.trim();\n  return str;\n}; //'!' starts a header-row\n\n\nvar findHeaders = function findHeaders() {\n  var rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var headers = [];\n  var first = rows[0];\n\n  if (first && first[0] && /^!/.test(first[0]) === true) {\n    headers = first.map(function (h) {\n      h = h.replace(/^\\! */, '');\n      h = cleanText(h);\n      return h;\n    });\n    rows.shift();\n  } //try the second row, too (overwrite first-row, if it exists)\n\n\n  first = rows[0];\n\n  if (first && first[0] && first[1] && /^!/.test(first[0]) && /^!/.test(first[1])) {\n    first.forEach(function (h, i) {\n      h = h.replace(/^\\! */, '');\n      h = cleanText(h);\n\n      if (Boolean(h) === true) {\n        headers[i] = h;\n      }\n    });\n    rows.shift();\n  }\n\n  return headers;\n}; //turn headers, array into an object\n\n\nvar parseRow = function parseRow(arr, headers) {\n  var row = {};\n  arr.forEach(function (str, i) {\n    var h = headers[i] || 'col' + (i + 1);\n    var s = parseSentence(str);\n    s.text(cleanText(s.text()));\n    row[h] = s;\n  });\n  return row;\n}; //should we use the first row as a the headers?\n\n\nvar firstRowHeader = function firstRowHeader(rows) {\n  if (rows.length <= 3) {\n    return [];\n  }\n\n  var headers = rows[0].slice(0);\n  headers = headers.map(function (h) {\n    h = h.replace(/^\\! */, '');\n    h = parseSentence(h).text();\n    h = cleanText(h);\n    h = h.toLowerCase();\n    return h;\n  });\n\n  for (var i = 0; i < headers.length; i += 1) {\n    if (headings.hasOwnProperty(headers[i])) {\n      rows.shift();\n      return headers;\n    }\n  }\n\n  return [];\n}; //turn a {|...table string into an array of arrays\n\n\nvar parseTable = function parseTable(wiki) {\n  var lines = wiki.replace(/\\r/g, '').split(/\\n/);\n  lines = lines.map(function (l) {\n    return l.trim();\n  });\n  var rows = findRows(lines); //support colspan, rowspan...\n\n  rows = handleSpans(rows); //grab the header rows\n\n  var headers = findHeaders(rows);\n\n  if (!headers || headers.length <= 1) {\n    headers = firstRowHeader(rows);\n    var want = rows[rows.length - 1] || []; //try the second row\n\n    if (headers.length <= 1 && want.length > 2) {\n      headers = firstRowHeader(rows.slice(1));\n\n      if (headers.length > 0) {\n        rows = rows.slice(2); //remove them\n      }\n    }\n  } //index each column by it's header\n\n\n  var table = rows.map(function (arr) {\n    return parseRow(arr, headers);\n  });\n  return table;\n};\n\nmodule.exports = parseTable;","map":null,"metadata":{},"sourceType":"script"}